COMMON_ID=75
COMMON_NAME=X[Map]Add/Remove State
COMMAND_COLOR=6
TRIGGER=32
TRIGGER_TARGET=2000000
TRIGGER_VAL=0
MEMO=
VALINPUT_NUM=3
STRINPUT_NUM=0
VALINPUT_NAME_NUM=11
VALINPUT_NAME_0=Ally ID
VALINPUT_NAME_1=State
VALINPUT_NAME_2=Action
VALINPUT_NAME_3=
VALINPUT_NAME_4=
VALINPUT_NAME_5=
VALINPUT_NAME_6=
VALINPUT_NAME_7=
VALINPUT_NAME_8=
VALINPUT_NAME_9=0
VALINPUT_NAME_10=
LOADTYPE_NUM=10
LOADTYPE0=0
LOADTYPE1=1
LOADTYPE2=2
LOADTYPE3=0
LOADTYPE4=0
LOADTYPE5=0
LOADTYPE6=0
LOADTYPE7=0
LOADTYPE8=0
LOADTYPE9=0
CHOICE_STR_NUM=10
CHOICE_STR_0_NUM=0
CHOICE_STR_1_NUM=3
CHOICE_STR_1_0=Remove All (Force)
CHOICE_STR_1_1=Remove All (Only Full Recovery Targets)
CHOICE_STR_1_2=Remove All (Full Recovery Targets Excluding Fainting)
CHOICE_STR_2_NUM=3
CHOICE_STR_2_0=Remove
CHOICE_STR_2_1=Add
CHOICE_STR_2_2=Update
CHOICE_STR_3_NUM=0
CHOICE_STR_4_NUM=0
CHOICE_STR_5_NUM=0
CHOICE_STR_6_NUM=0
CHOICE_STR_7_NUM=0
CHOICE_STR_8_NUM=0
CHOICE_STR_9_NUM=0
CHOICE_VAL_NUM=10
CHOICE_VAL_0_NUM=0
CHOICE_VAL_1_NUM=3
CHOICE_VAL_1_0=1
CHOICE_VAL_1_1=8
CHOICE_VAL_1_2=1
CHOICE_VAL_2_NUM=3
CHOICE_VAL_2_0=0
CHOICE_VAL_2_1=1
CHOICE_VAL_2_2=2
CHOICE_VAL_3_NUM=0
CHOICE_VAL_4_NUM=0
CHOICE_VAL_5_NUM=0
CHOICE_VAL_6_NUM=0
CHOICE_VAL_7_NUM=0
CHOICE_VAL_8_NUM=0
CHOICE_VAL_9_NUM=0
DEFAULT_VAL_NUM=5
DEFAULT_VAL_0=0
DEFAULT_VAL_1=0
DEFAULT_VAL_2=0
DEFAULT_VAL_3=0
DEFAULT_VAL_4=0
RETURN_VAL_NAME=
RETURN_VAL_TARGET=-1
CSELF_NAME_0=Ally ID
CSELF_NAME_1=State
CSELF_NAME_2=Remove=0, Add=1, Update=2
CSELF_NAME_3=
CSELF_NAME_4=
CSELF_NAME_5=
CSELF_NAME_6=
CSELF_NAME_7=
CSELF_NAME_8=
CSELF_NAME_9=State Display Text
CSELF_NAME_10=Total State Count
CSELF_NAME_11=Processing State ID
CSELF_NAME_12=Base Turns
CSELF_NAME_13=Change Turns
CSELF_NAME_14=Total Turns
CSELF_NAME_15=Full Recovery Target?
CSELF_NAME_16=Category (1=Work on Map)
CSELF_NAME_17=Turns Left
CSELF_NAME_18=Remove All Flag (State ID to Keep, -1 for None)
CSELF_NAME_19=
CSELF_NAME_20=Temp Variable A
CSELF_NAME_21=Fainted Turn Count
CSELF_NAME_22=Display States?
CSELF_NAME_23=State Display Count (New Line Every 4)
CSELF_NAME_24=Put Slash (/) in State Display?
CSELF_NAME_25=Faint Handling
CSELF_NAME_26=
CSELF_NAME_27=
CSELF_NAME_28=
CSELF_NAME_29=
CSELF_NAME_30=Stacking State Check
CSELF_NAME_31=Stacking State
CSELF_NAME_32=Post-Change State
CSELF_NAME_33=Final Resulting State
CSELF_NAME_34=Pre-Change State
CSELF_NAME_35=
CSELF_NAME_36=
CSELF_NAME_37=
CSELF_NAME_38=
CSELF_NAME_39=
CSELF_NAME_40=
CSELF_NAME_41=
CSELF_NAME_42=
CSELF_NAME_43=
CSELF_NAME_44=
CSELF_NAME_45=
CSELF_NAME_46=
CSELF_NAME_47=
CSELF_NAME_48=
CSELF_NAME_49=
CSELF_NAME_50=
CSELF_NAME_51=
CSELF_NAME_52=
CSELF_NAME_53=
CSELF_NAME_54=
CSELF_NAME_55=
CSELF_NAME_56=
CSELF_NAME_57=
CSELF_NAME_58=
CSELF_NAME_59=
CSELF_NAME_60=
CSELF_NAME_61=
CSELF_NAME_62=
CSELF_NAME_63=
CSELF_NAME_64=
CSELF_NAME_65=
CSELF_NAME_66=
CSELF_NAME_67=
CSELF_NAME_68=
CSELF_NAME_69=
CSELF_NAME_70=
CSELF_NAME_71=
CSELF_NAME_72=
CSELF_NAME_73=
CSELF_NAME_74=
CSELF_NAME_75=
CSELF_NAME_76=
CSELF_NAME_77=
CSELF_NAME_78=
CSELF_NAME_79=
CSELF_NAME_80=
CSELF_NAME_81=
CSELF_NAME_82=
CSELF_NAME_83=
CSELF_NAME_84=
CSELF_NAME_85=
CSELF_NAME_86=
CSELF_NAME_87=
CSELF_NAME_88=
CSELF_NAME_89=
CSELF_NAME_90=
CSELF_NAME_91=
CSELF_NAME_92=
CSELF_NAME_93=
CSELF_NAME_94=
CSELF_NAME_95=
CSELF_NAME_96=
CSELF_NAME_97=
CSELF_NAME_98=
CSELF_NAME_99=
COMMAND_NUM=339
--
WoditorEvCOMMAND_START
[103][0,1]<0>()("―――――――――――――――――――――――――――――――――――")
[103][0,1]<0>()("[Process Overview]")
[103][0,1]<0>()("  This common event is always used to add or remove states on the ally in the base system.")
[103][0,1]<0>()("  Works only on the map.")
[103][0,1]<0>()(" ")
[103][0,1]<0>()("  Also, handles HP changes related to the fainted state.")
[103][0,1]<0>()(" ")
[103][0,1]<0>()("  After processing, to reduce load,")
[103][0,1]<0>()("  information on whether currently affected by a state and the minimum number of steps remaining until removal")
[103][0,1]<0>()("  is stored in the allies' temporary database.")
[103][0,1]<0>()("")
[103][0,1]<0>()("[Databases Accessed by This Common Event]")
[103][0,1]<0>()(" ")
[103][0,1]<0>()("[Other Common Events Called from Here]")
[103][0,1]<0>()(" ")
[103][0,1]<0>()("[Main Common Events Calling This]")
[103][0,1]<0>()("―――――――――――――――――――――――――――――――――――")
[121][4,0]<0>(1600018,-1,0,0)()
[111][4,0]<0>(1,1600002,2,2)()
[401][1,0]<0>(1)()
[213][0,1]<1>()("Update")
[0][0,0]<1>()()
[499][0,0]<0>()()
[111][4,0]<0>(1,1600000,0,4)()
[401][1,0]<0>(1)()
[106][0,1]<1>()("[Error]<\n> Ally ID cannot be<\n> less than 0.")
[172][0,0]<1>()()
[0][0,0]<1>()()
[499][0,0]<0>()()
[111][7,0]<0>(18,1600001,0,1,1600001,-1,3)()
[401][1,0]<0>(1)()
[103][0,1]<1>()("■■■■■■■■■■■■■■■■■■■■■■■■■■■■■")
[103][0,1]<1>()("Add or remove only the specified state.")
[103][0,1]<1>()("■■■■■■■■■■■■■■■■■■■■■■■■■■■■■")
[250][5,4]<1>(8,1600001,7,332288,1600016)("","States","","Category (Battle/Map)")
[111][4,0]<1>(1,1600016,0,2)()
[401][1,0]<1>(1)()
[103][0,1]<2>()("If it's battle-only, end.")
[172][0,0]<2>()()
[0][0,0]<2>()()
[499][0,0]<1>()()
[121][4,0]<1>(1600011,1600001,0,0)()
[250][5,4]<1>(8,-1,7,70144,1600010)("","States","","")
[111][4,0]<1>(1,1600011,1600010,1)()
[401][1,0]<1>(1)()
[106][0,1]<2>()("[Error]<\n> State ID is too large > \cself[1]")
[172][0,0]<2>()()
[0][0,0]<2>()()
[499][0,0]<1>()()
[111][7,0]<1>(2,1600002,1,2,1600002,0,2)()
[401][1,0]<1>(1)()
[103][0,1]<2>()("If State ID is negative, do nothing.")
[111][4,0]<2>(1,1600011,-1,3)()
[401][1,0]<2>(1)()
[172][0,0]<3>()()
[0][0,0]<3>()()
[499][0,0]<2>()()
[179][1,0]<2>(1)()
[103][0,1]<3>()("First, check for a state that changes when stacked. If found, end this process and proceed to apply the post-change state.")
[103][0,1]<3>()("(However, if the post-change state is the same, ignore it.)")
[121][4,0]<3>(1600030,-1,0,0)()
[121][4,0]<3>(1600033,-10,0,0)()
[179][1,0]<3>(1600010)()
[121][4,0]<4>(1600030,1,0,256)()
[250][5,4]<4>(2,1600000,1600030,69632,1600017)("","┗ State List","","")
[111][4,0]<4>(1,1600017,0,5)()
[401][1,0]<4>(1)()
[103][0,1]<5>()("Check if the state changes when stacked.")
[250][5,4]<5>(8,1600030,10,332288,1600031)("","States","","When This State Is Stacked...")
[111][4,0]<5>(1,1600031,1600011,2)()
[401][1,0]<5>(1)()
[250][5,4]<6>(8,1600030,11,332288,1600032)("","States","","┗ Make It Into This State")
[103][0,1]<6>()("Process only if the new state to be added and the post-change state are different.")
[111][4,0]<6>(1,1600031,1600032,5)()
[401][1,0]<6>(1)()
[121][4,0]<7>(1600033,1600032,0,0)()
[121][4,0]<7>(1600034,1600030,0,0)()
[0][0,0]<7>()()
[499][0,0]<6>()()
[0][0,0]<6>()()
[499][0,0]<5>()()
[0][0,0]<5>()()
[499][0,0]<4>()()
[0][0,0]<4>()()
[498][0,0]<3>()()
[111][10,0]<3>(3,1600033,-10,2,1600033,0,1,1600033,-1,3)()
[401][1,0]<3>(1)()
[103][0,1]<4>()("If it's still -10, there's no changeable state, so proceed (processing is empty).")
[0][0,0]<4>()()
[401][1,0]<3>(2)()
[103][0,1]<4>()("If there's a changeable state")
[103][0,1]<4>()(" ")
[103][0,1]<4>()("Remove pre-change state.")
[250][5,4]<4>(2,1600000,1600034,65536,0)("","┗ State List","","")
[103][0,1]<4>()("Add post-change state.")
[210][5,0]<4>(600100,3,1600000,1600032,1)()
[172][0,0]<4>()()
[0][0,0]<4>()()
[401][1,0]<3>(3)()
[103][0,1]<4>()("If removed")
[210][5,0]<4>(600100,3,1600000,1600034,0)()
[172][0,0]<4>()()
[0][0,0]<4>()()
[499][0,0]<3>()()
[0][0,0]<3>()()
[498][0,0]<2>()()
[179][1,0]<2>(1)()
[103][0,1]<3>()("First, check if it's a state that causes fainting.")
[250][5,4]<3>(8,1600011,15,332288,1600020)("","States","","Count as Fainted?")
[111][4,0]<3>(1,1600020,2,2)()
[401][1,0]<3>(1)()
[103][0,1]<4>()("If it's set to <dqrt>On Apply: HP 0 (State 0),<dqrt> cause instant death.")
[103][0,1]<4>()("Set the processing state to <dqrt>fainted.<dqrt>")
[121][4,0]<4>(1600001,0,0,0)()
[121][4,0]<4>(1600011,0,0,0)()
[0][0,0]<4>()()
[499][0,0]<3>()()
[0][0,0]<3>()()
[498][0,0]<2>()()
[103][0,1]<2>()("Calculate remaining turns. (If base turn is -1, infinite)")
[250][5,4]<2>(8,1600011,4,332288,1600012)("","States","","Duration in Turns [-1:Infinite]")
[111][4,0]<2>(17,1600012,0,1)()
[401][1,0]<2>(1)()
[250][5,4]<3>(8,1600011,5,332288,1600013)("","States","","┗ Duration Variance [±]")
[121][4,0]<3>(1600014,1600012,1600013,4096)()
[121][4,0]<3>(1600013,2,0,768)()
[121][4,0]<3>(1600014,0,1600013,24832)()
[121][4,0]<3>(1600014,1,0,1536)()
[103][0,1]<3>()("If necessary, raise the steps until the next state removal in the Temp DB.")
[250][5,4]<3>(21,1600000,12,327776,1600014)("","×Allies Temp Data","","[Tmp] UntilNextStateRemove")
[0][0,0]<3>()()
[420][1,0]<2>(0)()
[103][0,1]<3>()("If the state lasts indefinitely, store -1.")
[121][4,0]<3>(1600014,-1,0,0)()
[0][0,0]<3>()()
[499][0,0]<2>()()
[250][5,4]<2>(2,1600000,1600011,65536,1600014)("","┗ State List","","")
[103][0,1]<2>()("Check whether to remove all other states.")
[250][5,4]<2>(8,1600011,19,332288,1600020)("","States","","All Other States...")
[111][4,0]<2>(1,1600020,1,2)()
[401][1,0]<2>(1)()
[121][4,0]<3>(1600018,1600011,0,0)()
[0][0,0]<3>()()
[499][0,0]<2>()()
[0][0,0]<2>()()
[401][1,0]<1>(2)()
[103][0,1]<2>()("Set remaining turns to 0.")
[250][5,4]<2>(2,1600000,1600011,65536,0)("","┗ State List","","")
[0][0,0]<2>()()
[499][0,0]<1>()()
[0][0,0]<1>()()
[401][1,0]<0>(2)()
[111][4,0]<1>(1,1600002,1,2)()
[401][1,0]<1>(1)()
[106][0,1]<2>()("[Error]<\n> Cannot <dqrt>add<dqrt> all states.")
[172][0,0]<2>()()
[0][0,0]<2>()()
[499][0,0]<1>()()
[111][4,0]<1>(1,1600002,0,2)()
[401][1,0]<1>(1)()
[103][0,1]<2>()("■■■■■■■■■■■■■■■■■■■■■■■■■■■■■")
[103][0,1]<2>()("■ When removing all states")
[103][0,1]<2>()("-1: Forcibly remove all states / -2: Remove only states that are removed on full recovery")
[103][0,1]<2>()("■■■■■■■■■■■■■■■■■■■■■■■■■■■■■")
[250][5,4]<2>(8,-1,7,70144,1600010)("","States","","")
[121][4,0]<2>(1600011,-1,0,0)()
[111][4,0]<2>(1,1600001,-1,2)()
[401][1,0]<2>(1)()
[103][0,1]<3>()("Force remove all.")
[250][5,4]<3>(5,1600000,-2,65536,0)("","┗ State List","","")
[250][5,4]<3>(0,1600000,0,327776,1)("","Allies","","HP")
[0][0,0]<3>()()
[499][0,0]<2>()()
[111][4,0]<2>(1,1600001,-3,3)()
[401][1,0]<2>(1)()
[103][0,1]<3>()("Remove all except fainting.")
[121][4,0]<3>(1600010,1,0,512)()
[121][4,0]<3>(1600011,0,0,0)()
[121][4,0]<3>(1600001,-2,0,0)()
[0][0,0]<3>()()
[499][0,0]<2>()()
[179][1,0]<2>(1600010)()
[121][4,0]<3>(1600011,1,0,256)()
[103][0,1]<3>()("If the state is -2, remove only states that are removed on full recovery.")
[111][4,0]<3>(1,1600001,-2,2)()
[401][1,0]<3>(1)()
[250][5,4]<4>(8,1600011,0,332288,1600015)("","States","","Removed by Full Recovery?")
[111][4,0]<4>(1,1600015,0,2)()
[401][1,0]<4>(1)()
[103][0,1]<5>()("If not subject to full recovery, skip.")
[176][0,0]<5>()()
[0][0,0]<5>()()
[499][0,0]<4>()()
[0][0,0]<4>()()
[499][0,0]<3>()()
[250][5,4]<3>(2,1600000,1600011,65536,0)("","┗ State List","","")
[0][0,0]<3>()()
[498][0,0]<2>()()
[0][0,0]<2>()()
[499][0,0]<1>()()
[0][0,0]<1>()()
[420][1,0]<0>(0)()
[106][0,1]<1>()("[Error]<\n> State -3 or lower cannot be specified<\n> for state addition/removal.")
[172][0,0]<1>()()
[0][0,0]<1>()()
[499][0,0]<0>()()
[212][0,1]<0>()("Update")
[103][0,1]<0>()(" ")
[103][0,1]<0>()("Adjust HP depending on whether fainted or not.")
[250][5,4]<0>(2,1600000,0,69632,1600021)("","┗ State List","","")
[250][5,4]<0>(18,0,19,332288,1600025)("","System Settings","","Fainted Members After Battle")
[111][7,0]<0>(2,1600025,0,2,1600025,1,2)()
[401][1,0]<0>(1)()
[103][0,1]<1>()("If system is set to <dqrt>Stay Fainted<dqrt>")
[111][7,0]<1>(2,1600021,0,2,1600021,0,5)()
[401][1,0]<1>(1)()
[103][0,1]<2>()("If not fainted, ensure HP is at least 1.")
[250][5,4]<2>(0,1600000,0,327776,1)("","Allies","","HP")
[0][0,0]<2>()()
[401][1,0]<1>(2)()
[103][0,1]<2>()("If fainted, ensure HP is 0.")
[250][5,4]<2>(0,1600000,0,327680,0)("","Allies","","HP")
[0][0,0]<2>()()
[499][0,0]<1>()()
[0][0,0]<1>()()
[401][1,0]<0>(2)()
[103][0,1]<1>()("If system is set to <dqrt>Revive with 1 HP<dqrt>")
[250][5,4]<1>(2,1600000,0,65536,0)("","┗ State List","","")
[250][5,4]<1>(0,1600000,0,327776,1)("","Allies","","HP")
[103][0,1]<1>()("Remove fainted state.")
[121][4,0]<1>(1600021,0,0,0)()
[0][0,0]<1>()()
[499][0,0]<0>()()
[103][0,1]<0>()("If <dqrt>Fainted<dqrt> is set to remove all other states, store fainted (ID 0) as the state excluded when removing all states.")
[111][4,0]<0>(1,1600021,0,5)()
[401][1,0]<0>(1)()
[250][5,4]<1>(8,0,0,332288,1600020)("","States","","All Other States...")
[111][4,0]<1>(1,1600020,1,2)()
[401][1,0]<1>(1)()
[121][4,0]<2>(1600018,0,0,0)()
[0][0,0]<2>()()
[499][0,0]<1>()()
[0][0,0]<1>()()
[499][0,0]<0>()()
[103][0,1]<0>()(" ")
[103][0,1]<0>()("If the state is set to remove all other states, set all states to 0 except that state and fainted.")
[111][4,0]<0>(1,1600018,0,1)()
[401][1,0]<0>(1)()
[103][0,1]<1>()("Get the remaining steps of the state to be kept, then reset.")
[250][5,4]<1>(2,1600000,1600018,69632,1600020)("","┗ State List","","")
[250][5,4]<1>(2,1600000,-2,65536,1600020)("","┗ State List","","")
[103][0,1]<1>()("Since all are set to 0, set the remaining turns (steps).")
[250][5,4]<1>(2,1600000,0,65536,1600021)("","┗ State List","","")
[250][5,4]<1>(2,1600000,1600018,65536,1600020)("","┗ State List","","")
[0][0,0]<1>()()
[499][0,0]<0>()()
[103][0,1]<0>()(" ")
[179][1,0]<0>(1)()
[103][0,1]<1>()("Finally, store whether an ally has each state and, if so,")
[103][0,1]<1>()("how many turns remain until it's removed, in the allies temporary database.")
[103][0,1]<1>()("Also, calculate HP/SP change per step on the map.")
[121][4,0]<1>(1600023,0,0,0)()
[122][2,1]<1>(1600009,0)("")
[250][5,4]<1>(18,0,17,332288,1600024)("","System Settings","","States Display")
[103][0,1]<1>()("Initialize.")
[250][5,4]<1>(21,1600000,9,327680,0)("","×Allies Temp Data","","[Temp] Has States on Map?")
[250][5,4]<1>(21,1600000,0,327680,999999)("","×Allies Temp Data","","[Tmp] UntilNextStateRemove")
[250][5,4]<1>(17,1600000,11,327680,0)("","×Allies Temp Data","","[Temp] HP Auto Change")
[250][5,4]<1>(17,1600000,12,327680,0)("","×Allies Temp Data","","[Temp] SP Auto Change")
[250][5,4]<1>(17,1600000,16,327680,0)("","×Allies Temp Data","","[Temp] Sealed?")
[103][0,1]<1>()("Check all states.")
[250][5,4]<1>(8,-1,7,70144,1600010)("","States","","")
[121][4,0]<1>(1600011,-1,0,0)()
[179][1,0]<1>(1600010)()
[121][4,0]<2>(1600011,1,0,256)()
[250][5,4]<2>(2,1600000,1600011,69632,1600017)("","┗ State List","","")
[111][4,0]<2>(1,1600017,0,5)()
[401][1,0]<2>(1)()
[111][7,0]<3>(2,1600017,1,1,1600017,-1,2)()
[401][1,0]<3>(1)()
[103][0,1]<4>()("Store the steps until the next state is removed in the temporary database.")
[250][5,4]<4>(21,1600000,0,327792,1600017)("","×Allies Temp Data","","[Tmp] UntilNextStateRemove")
[250][5,4]<4>(21,1600000,0,327680,1)("","×Allies Temp Data","","[Temp] Has States on Map?")
[0][0,0]<4>()()
[401][1,0]<3>(2)()
[250][5,4]<4>(21,1600000,0,327680,1)("","×Allies Temp Data","","[Temp] Has States on Map?")
[0][0,0]<4>()()
[499][0,0]<3>()()
[103][0,1]<3>()("Add HP/SP auto-change amount.")
[250][5,4]<3>(8,1600011,34,332288,1600020)("","States","","HP Change ±(1 Step on Map)")
[250][5,4]<3>(24,1600000,10,327696,1600020)("","×Allies Temp Data","","[Temp] HP Auto Change")
[250][5,4]<3>(8,1600011,35,332288,1600020)("","States","","SP Change ± (1 Step on Map)")
[250][5,4]<3>(24,1600000,11,327696,1600020)("","×Allies Temp Data","","[Temp] SP Auto Change")
[103][0,1]<3>()("Check for sealed state.")
[250][5,4]<3>(8,1600011,17,332288,1600020)("","States","","Skill Limitation")
[250][5,4]<3>(17,1600000,16,327776,1600020)("","×Allies Temp Data","","[Temp] Sealed?")
[103][0,1]<3>()("If the state is displayed in the status, add it to the state name list.")
[250][5,4]<3>(8,1600011,0,332288,1600022)("","States","","Display Type")
[111][4,0]<3>(1,1600022,1,6)()
[401][1,0]<3>(1)()
[111][4,0]<4>(1,1600023,4,1)()
[401][1,0]<4>(1)()
[121][4,0]<5>(1600023,4,0,1280)()
[111][4,0]<5>(1,1600023,0,2)()
[401][1,0]<5>(1)()
[122][2,1]<6>(1600009,256)("<\n>")
[0][0,0]<6>()()
[499][0,0]<5>()()
[0][0,0]<5>()()
[499][0,0]<4>()()
[111][4,0]<4>(1,1600024,1,2)()
[401][1,0]<4>(1)()
[111][4,0]<5>(1,1600023,0,5)()
[401][1,0]<5>(1)()
[122][2,1]<6>(1600009,256)("/")
[0][0,0]<6>()()
[499][0,0]<5>()()
[0][0,0]<5>()()
[499][0,0]<4>()()
[250][5,4]<4>(8,1600011,0,332304,1600009)("","States","","Display Name")
[121][4,0]<4>(1600023,1,0,256)()
[0][0,0]<4>()()
[499][0,0]<3>()()
[0][0,0]<3>()()
[499][0,0]<2>()()
[0][0,0]<2>()()
[498][0,0]<1>()()
[103][0,1]<1>()("Copy to maximum removal turns. This value is used when reducing the remaining steps of all states at once during state removal.")
[250][5,4]<1>(21,1600000,0,331776,1600017)("","×Allies Temp Data","","[Tmp] UntilNextStateRemove")
[250][5,4]<1>(21,1600000,0,327680,1600017)("","×Allies Temp Data","","[Tmp] NextStateRemoveMax")
[103][0,1]<1>()("Store state display string.")
[250][5,4]<1>(21,1600000,14,327680,1600009)("","×Allies Temp Data","","[Temp] State Names")
[103][0,1]<1>()(" ")
[103][0,1]<1>()("If no states are removed by turn progression,")
[103][0,1]<1>()("the remaining steps until the next state removal will be 999999 at this point, but it's not a problem.")
[103][0,1]<1>()("(This counter triggers state removal when it reaches 0, so keep it at 999999 to prevent that process from occurring.)")
[0][0,0]<1>()()
[498][0,0]<0>()()
[0][0,0]<0>()()
WoditorEvCOMMAND_END
--
[COMMAND_TEXT_START]
▼ ―――――――――――――――――――――――――――――――――――
▼ [Process Overview]
▼   This common event is always used to add or remove states on the ally in the base system.
▼   Works only on the map.
▼  
▼   Also, handles HP changes related to the fainted state.
▼  
▼   After processing, to reduce load,
▼   information on whether currently affected by a state and the minimum number of steps remaining until removal
▼   is stored in the allies' temporary database.
▼ 
▼ [Databases Accessed by This Common Event]
▼  
▼ [Other Common Events Called from Here]
▼  
▼ [Main Common Events Calling This]
▼ ―――――――――――――――――――――――――――――――――――
■Set Variable: CSelf18[Remove All Flag (State ID to Keep, -1 fo..] = -1 + 0 
■Condition (Number):   [1] CSelf2[Remove=0, Add=1, Update=2] ==  2  
-◇Condition:  [1]  [ CSelf2[Remove=0, Add=1, Update=2] == 2   ] Case↓
 |●Label Jump [Update] >>>>>>>>>>>>>>>>>>>>>>>>>
 |■
◇End◇
■Condition (Number):   [1] CSelf0[Ally ID] <  0  
-◇Condition:  [1]  [ CSelf0[Ally ID] < 0   ] Case↓
 |■Debug Text: [Error]\n Ally ID cannot be\n less than 0.
 |■Exit Event
 |■
◇End◇
■Condition (Number):   [1] CSelf1[State] >=  0  /  [2] CSelf1[State] <=  -1  
-◇Condition:  [1]  [ CSelf1[State] >= 0   ] Case↓
 |▼ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 |▼ Add or remove only the specified state.
 |▼ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 |■Load DB(User):  CSelf16[Category (1=Work on Map)] = UserDB[ "States":CSelf1[State]:"Category (Battle/Map)" ] (8:-:7) 
 |■Condition (Number):   [1] CSelf16[Category (1=Work on Map)] ==  0  
 |-◇Condition:  [1]  [ CSelf16[Category (1=Work on Map)] == 0   ] Case↓
 | |▼ If it's battle-only, end.
 | |■Exit Event
 | |■
 |◇End◇
 |■Set Variable: CSelf11[Processing State ID] = CSelf1[State] + 0 
 |■Load DB(User):  CSelf10[Total State Count] = UserDB[Type "States"(8)'s Data Count]
 |■Condition (Number):   [1] CSelf11[Processing State ID] >=  CSelf10[Total State Count]  
 |-◇Condition:  [1]  [ CSelf11[Processing State ID] >= CSelf10[Total State Count]   ] Case↓
 | |■Debug Text: [Error]\n State ID is too large > \cself[1]
 | |■Exit Event
 | |■
 |◇End◇
 |■Condition (Number):   [1] CSelf2[Remove=0, Add=1, Update=2] ==  1  /  [2] CSelf2[Remove=0, Add=1, Update=2] ==  0  
 |-◇Condition:  [1]  [ CSelf2[Remove=0, Add=1, Update=2] == 1   ] Case↓
 | |▼ If State ID is negative, do nothing.
 | |■Condition (Number):   [1] CSelf11[Processing State ID] <=  -1  
 | |-◇Condition:  [1]  [ CSelf11[Processing State ID] <= -1   ] Case↓
 | | |■Exit Event
 | | |■
 | |◇End◇
 | |■Repeat Loop [ 1 ] Times
 | | |▼ First, check for a state that changes when stacked. If found, end this process and proceed to apply the post-change state.
 | | |▼ (However, if the post-change state is the same, ignore it.)
 | | |■Set Variable: CSelf30[Stacking State Check] = -1 + 0 
 | | |■Set Variable: CSelf33[Final Resulting State] = -10 + 0 
 | | |■Repeat Loop [ CSelf10[Total State Count] ] Times
 | | | |■Set Variable: CSelf30[Stacking State Check] += 1 + 0 
 | | | |■Load DB(Var):  CSelf17[Turns Left] = VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf30[Stacking State Check] ] (5:-:-) 
 | | | |■Condition (Number):   [1] CSelf17[Turns Left] !=  0  
 | | | |-◇Condition:  [1]  [ CSelf17[Turns Left] != 0   ] Case↓
 | | | | |▼ Check if the state changes when stacked.
 | | | | |■Load DB(User):  CSelf31[Stacking State] = UserDB[ "States":CSelf30[Stacking State Check]:"When This State Is Stacked..." ] (8:-:10) 
 | | | | |■Condition (Number):   [1] CSelf31[Stacking State] ==  CSelf11[Processing State ID]  
 | | | | |-◇Condition:  [1]  [ CSelf31[Stacking State] == CSelf11[Processing State ID]   ] Case↓
 | | | | | |■Load DB(User):  CSelf32[Post-Change State] = UserDB[ "States":CSelf30[Stacking State Check]:"┗ Make It Into This State" ] (8:-:11) 
 | | | | | |▼ Process only if the new state to be added and the post-change state are different.
 | | | | | |■Condition (Number):   [1] CSelf31[Stacking State] !=  CSelf32[Post-Change State]  
 | | | | | |-◇Condition:  [1]  [ CSelf31[Stacking State] != CSelf32[Post-Change State]   ] Case↓
 | | | | | | |■Set Variable: CSelf33[Final Resulting State] = CSelf32[Post-Change State] + 0 
 | | | | | | |■Set Variable: CSelf34[Pre-Change State] = CSelf30[Stacking State Check] + 0 
 | | | | | | |■
 | | | | | |◇End◇
 | | | | | |■
 | | | | |◇End◇
 | | | | |■
 | | | |◇End◇
 | | | |■
 | | |◇Loop End Point◇◇
 | | |■Condition (Number):   [1] CSelf33[Final Resulting State] ==  -10  /  [2] CSelf33[Final Resulting State] >=  0  /  [3] CSelf33[Final Resulting State] <=  -1  
 | | |-◇Condition:  [1]  [ CSelf33[Final Resulting State] == -10   ] Case↓
 | | | |▼ If it's still -10, there's no changeable state, so proceed (processing is empty).
 | | | |■
 | | |-◇Condition:  [2]  [ CSelf33[Final Resulting State] >= 0   ] Case↓
 | | | |▼ If there's a changeable state
 | | | |▼  
 | | | |▼ Remove pre-change state.
 | | | |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf34[Pre-Change State] ] (5:-:-) =  0
 | | | |▼ Add post-change state.
 | | | |■Call Event: [+0 From This Common]  Common 75: [ X[Map]Add/Remove State ] / CSelf0[Ally ID] / CSelf32[Post-Change State] / 1:Add
 | | | |■Exit Event
 | | | |■
 | | |-◇Condition:  [3]  [ CSelf33[Final Resulting State] <= -1   ] Case↓
 | | | |▼ If removed
 | | | |■Call Event: [+0 From This Common]  Common 75: [ X[Map]Add/Remove State ] / CSelf0[Ally ID] / CSelf34[Pre-Change State] / 0:Remove
 | | | |■Exit Event
 | | | |■
 | | |◇End◇
 | | |■
 | |◇Loop End Point◇◇
 | |■Repeat Loop [ 1 ] Times
 | | |▼ First, check if it's a state that causes fainting.
 | | |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":CSelf11[Processing State ID]:"Count as Fainted?" ] (8:-:15) 
 | | |■Condition (Number):   [1] CSelf20[Temp Variable A] ==  2  
 | | |-◇Condition:  [1]  [ CSelf20[Temp Variable A] == 2   ] Case↓
 | | | |▼ If it's set to "On Apply: HP 0 (State 0)," cause instant death.
 | | | |▼ Set the processing state to "fainted."
 | | | |■Set Variable: CSelf1[State] = 0 + 0 
 | | | |■Set Variable: CSelf11[Processing State ID] = 0 + 0 
 | | | |■
 | | |◇End◇
 | | |■
 | |◇Loop End Point◇◇
 | |▼ Calculate remaining turns. (If base turn is -1, infinite)
 | |■Load DB(User):  CSelf12[Base Turns] = UserDB[ "States":CSelf11[Processing State ID]:"Duration in Turns [-1:Infinite]" ] (8:-:4) 
 | |■Condition (Number):   [1] CSelf12[Base Turns] >=  0  
 | |-◇Condition:  [1]  [ CSelf12[Base Turns] >= 0   ] Case↓
 | | |■Load DB(User):  CSelf13[Change Turns] = UserDB[ "States":CSelf11[Processing State ID]:"┗ Duration Variance [±]" ] (8:-:5) 
 | | |■Set Variable: CSelf14[Total Turns] = CSelf12[Base Turns] - CSelf13[Change Turns] 
 | | |■Set Variable: CSelf13[Change Turns] *= 2 + 0 
 | | |■Set Variable: CSelf14[Total Turns] += 0  to  CSelf13[Change Turns] 
 | | |■Set Variable: CSelf14[Total Turns] Lower Bound= 1 + 0 
 | | |▼ If necessary, raise the steps until the next state removal in the Temp DB.
 | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Tmp] UntilNextStateRemove" ] (17:-:13) Lower Bound  CSelf14[Total Turns]
 | | |■
 | |-◇Else
 | | |▼ If the state lasts indefinitely, store -1.
 | | |■Set Variable: CSelf14[Total Turns] = -1 + 0 
 | | |■
 | |◇End◇
 | |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf11[Processing State ID] ] (5:-:-) =  CSelf14[Total Turns]
 | |▼ Check whether to remove all other states.
 | |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":CSelf11[Processing State ID]:"All Other States..." ] (8:-:18) 
 | |■Condition (Number):   [1] CSelf20[Temp Variable A] ==  1  
 | |-◇Condition:  [1]  [ CSelf20[Temp Variable A] == 1   ] Case↓
 | | |■Set Variable: CSelf18[Remove All Flag (State ID to Keep, -1 fo..] = CSelf11[Processing State ID] + 0 
 | | |■
 | |◇End◇
 | |■
 |-◇Condition:  [2]  [ CSelf2[Remove=0, Add=1, Update=2] == 0   ] Case↓
 | |▼ Set remaining turns to 0.
 | |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf11[Processing State ID] ] (5:-:-) =  0
 | |■
 |◇End◇
 |■
-◇Condition:  [2]  [ CSelf1[State] <= -1   ] Case↓
 |■Condition (Number):   [1] CSelf2[Remove=0, Add=1, Update=2] ==  1  
 |-◇Condition:  [1]  [ CSelf2[Remove=0, Add=1, Update=2] == 1   ] Case↓
 | |■Debug Text: [Error]\n Cannot "add" all states.
 | |■Exit Event
 | |■
 |◇End◇
 |■Condition (Number):   [1] CSelf2[Remove=0, Add=1, Update=2] ==  0  
 |-◇Condition:  [1]  [ CSelf2[Remove=0, Add=1, Update=2] == 0   ] Case↓
 | |▼ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 | |▼ ■ When removing all states
 | |▼ -1: Forcibly remove all states / -2: Remove only states that are removed on full recovery
 | |▼ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 | |■Load DB(User):  CSelf10[Total State Count] = UserDB[Type "States"(8)'s Data Count]
 | |■Set Variable: CSelf11[Processing State ID] = -1 + 0 
 | |■Condition (Number):   [1] CSelf1[State] ==  -1  
 | |-◇Condition:  [1]  [ CSelf1[State] == -1   ] Case↓
 | | |▼ Force remove all.
 | | |■Write to DB(Var): [Reset Type "┗ State List"(5) Data CSelf0[Ally ID]]
 | | |■Write to DB(Var): VarDB[ "Allies":CSelf0[Ally ID]:"HP" ] (0:-:6) Lower Bound  1
 | | |■
 | |◇End◇
 | |■Condition (Number):   [1] CSelf1[State] <=  -3  
 | |-◇Condition:  [1]  [ CSelf1[State] <= -3   ] Case↓
 | | |▼ Remove all except fainting.
 | | |■Set Variable: CSelf10[Total State Count] -= 1 + 0 
 | | |■Set Variable: CSelf11[Processing State ID] = 0 + 0 
 | | |■Set Variable: CSelf1[State] = -2 + 0 
 | | |■
 | |◇End◇
 | |■Repeat Loop [ CSelf10[Total State Count] ] Times
 | | |■Set Variable: CSelf11[Processing State ID] += 1 + 0 
 | | |▼ If the state is -2, remove only states that are removed on full recovery.
 | | |■Condition (Number):   [1] CSelf1[State] ==  -2  
 | | |-◇Condition:  [1]  [ CSelf1[State] == -2   ] Case↓
 | | | |■Load DB(User):  CSelf15[Full Recovery Target?] = UserDB[ "States":CSelf11[Processing State ID]:"Removed by Full Recovery?" ] (8:-:19) 
 | | | |■Condition (Number):   [1] CSelf15[Full Recovery Target?] ==  0  
 | | | |-◇Condition:  [1]  [ CSelf15[Full Recovery Target?] == 0   ] Case↓
 | | | | |▼ If not subject to full recovery, skip.
 | | | | |■Go to Loop Start
 | | | | |■
 | | | |◇End◇
 | | | |■
 | | |◇End◇
 | | |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf11[Processing State ID] ] (5:-:-) =  0
 | | |■
 | |◇Loop End Point◇◇
 | |■
 |◇End◇
 |■
-◇Else
 |■Debug Text: [Error]\n State -3 or lower cannot be specified\n for state addition/removal.
 |■Exit Event
 |■
◇End◇
●Label Point [Update] <<<<<<<<<<<<<<<<<<<<<<<<★
▼  
▼ Adjust HP depending on whether fainted or not.
■Load DB(Var):  CSelf21[Fainted Turn Count] = VarDB[ "┗ State List":CSelf0[Ally ID]:0 ] (5:-:\udb[8:0] Steps Left) 
■Load DB(User):  CSelf25[Faint Handling] = UserDB[ "System Settings":0:"Fainted Members After Battle" ] (17:Basic System Settings:21) 
■Condition (Number):   [1] CSelf25[Faint Handling] ==  0  /  [2] CSelf25[Faint Handling] ==  1  
-◇Condition:  [1]  [ CSelf25[Faint Handling] == 0   ] Case↓
 |▼ If system is set to "Stay Fainted"
 |■Condition (Number):   [1] CSelf21[Fainted Turn Count] ==  0  /  [2] CSelf21[Fainted Turn Count] !=  0  
 |-◇Condition:  [1]  [ CSelf21[Fainted Turn Count] == 0   ] Case↓
 | |▼ If not fainted, ensure HP is at least 1.
 | |■Write to DB(Var): VarDB[ "Allies":CSelf0[Ally ID]:"HP" ] (0:-:6) Lower Bound  1
 | |■
 |-◇Condition:  [2]  [ CSelf21[Fainted Turn Count] != 0   ] Case↓
 | |▼ If fainted, ensure HP is 0.
 | |■Write to DB(Var): VarDB[ "Allies":CSelf0[Ally ID]:"HP" ] (0:-:6) =  0
 | |■
 |◇End◇
 |■
-◇Condition:  [2]  [ CSelf25[Faint Handling] == 1   ] Case↓
 |▼ If system is set to "Revive with 1 HP"
 |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:0 ] (5:-:\udb[8:0] Steps Left) =  0
 |■Write to DB(Var): VarDB[ "Allies":CSelf0[Ally ID]:"HP" ] (0:-:6) Lower Bound  1
 |▼ Remove fainted state.
 |■Set Variable: CSelf21[Fainted Turn Count] = 0 + 0 
 |■
◇End◇
▼ If "Fainted" is set to remove all other states, store fainted (ID 0) as the state excluded when removing all states.
■Condition (Number):   [1] CSelf21[Fainted Turn Count] !=  0  
-◇Condition:  [1]  [ CSelf21[Fainted Turn Count] != 0   ] Case↓
 |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":0:"All Other States..." ] (8:Fainted:18) 
 |■Condition (Number):   [1] CSelf20[Temp Variable A] ==  1  
 |-◇Condition:  [1]  [ CSelf20[Temp Variable A] == 1   ] Case↓
 | |■Set Variable: CSelf18[Remove All Flag (State ID to Keep, -1 fo..] = 0 + 0 
 | |■
 |◇End◇
 |■
◇End◇
▼  
▼ If the state is set to remove all other states, set all states to 0 except that state and fainted.
■Condition (Number):   [1] CSelf18[Remove All Flag (State ID to Keep, -1 fo..] >=  0  
-◇Condition:  [1]  [ CSelf18[Remove All Flag (State ID to Keep, -1 fo..] >= 0   ] Case↓
 |▼ Get the remaining steps of the state to be kept, then reset.
 |■Load DB(Var):  CSelf20[Temp Variable A] = VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf18[Remove All Flag (State ID to Keep, -1 fo..] ] (5:-:-) 
 |■Write to DB(Var): [Reset Type "┗ State List"(5) Data CSelf0[Ally ID]]
 |▼ Since all are set to 0, set the remaining turns (steps).
 |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:0 ] (5:-:\udb[8:0] Steps Left) =  CSelf21[Fainted Turn Count]
 |■Write to DB(Var): VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf18[Remove All Flag (State ID to Keep, -1 fo..] ] (5:-:-) =  CSelf20[Temp Variable A]
 |■
◇End◇
▼  
■Repeat Loop [ 1 ] Times
 |▼ Finally, store whether an ally has each state and, if so,
 |▼ how many turns remain until it's removed, in the allies temporary database.
 |▼ Also, calculate HP/SP change per step on the map.
 |■Set Variable: CSelf23[State Display Count (New Line Every 4)] = 0 + 0 
 |■Set String: CSelf9[State Display Text] = ""
 |■Load DB(User):  CSelf24[Put Slash (/) in State Display?] = UserDB[ "System Settings":0:"States Display" ] (17:Basic System Settings:19) 
 |▼ Initialize.
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] Has States on Map?" ] (17:-:10) =  0
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Tmp] UntilNextStateRemove" ] (17:-:13) =  999999
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] HP Auto Change" ] (17:-:11) =  0
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] SP Auto Change" ] (17:-:12) =  0
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] Sealed?" ] (17:-:16) =  0
 |▼ Check all states.
 |■Load DB(User):  CSelf10[Total State Count] = UserDB[Type "States"(8)'s Data Count]
 |■Set Variable: CSelf11[Processing State ID] = -1 + 0 
 |■Repeat Loop [ CSelf10[Total State Count] ] Times
 | |■Set Variable: CSelf11[Processing State ID] += 1 + 0 
 | |■Load DB(Var):  CSelf17[Turns Left] = VarDB[ "┗ State List":CSelf0[Ally ID]:CSelf11[Processing State ID] ] (5:-:-) 
 | |■Condition (Number):   [1] CSelf17[Turns Left] !=  0  
 | |-◇Condition:  [1]  [ CSelf17[Turns Left] != 0   ] Case↓
 | | |■Condition (Number):   [1] CSelf17[Turns Left] >=  1  /  [2] CSelf17[Turns Left] ==  -1  
 | | |-◇Condition:  [1]  [ CSelf17[Turns Left] >= 1   ] Case↓
 | | | |▼ Store the steps until the next state is removed in the temporary database.
 | | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Tmp] UntilNextStateRemove" ] (17:-:13) Upper Bound  CSelf17[Turns Left]
 | | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] Has States on Map?" ] (17:-:10) =  1
 | | | |■
 | | |-◇Condition:  [2]  [ CSelf17[Turns Left] == -1   ] Case↓
 | | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] Has States on Map?" ] (17:-:10) =  1
 | | | |■
 | | |◇End◇
 | | |▼ Add HP/SP auto-change amount.
 | | |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":CSelf11[Processing State ID]:"HP Change ±(1 Step on Map)" ] (8:-:36) 
 | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] HP Auto Change" ] (17:-:11) +=  CSelf20[Temp Variable A]
 | | |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":CSelf11[Processing State ID]:"SP Change ± (1 Step on Map)" ] (8:-:37) 
 | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] SP Auto Change" ] (17:-:12) +=  CSelf20[Temp Variable A]
 | | |▼ Check for sealed state.
 | | |■Load DB(User):  CSelf20[Temp Variable A] = UserDB[ "States":CSelf11[Processing State ID]:"Skill Limitation" ] (8:-:17) 
 | | |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] Sealed?" ] (17:-:16) Lower Bound  CSelf20[Temp Variable A]
 | | |▼ If the state is displayed in the status, add it to the state name list.
 | | |■Load DB(User):  CSelf22[Display States?] = UserDB[ "States":CSelf11[Processing State ID]:"Display Type" ] (8:-:1) 
 | | |■Condition (Number):   [1] CSelf22[Display States?] &  1  
 | | |-◇Condition:  [1]  [ CSelf22[Display States?] & 1   ] Case↓
 | | | |■Condition (Number):   [1] CSelf23[State Display Count (New Line Every 4)] >=  4  
 | | | |-◇Condition:  [1]  [ CSelf23[State Display Count (New Line Every 4)] >= 4   ] Case↓
 | | | | |■Set Variable: CSelf23[State Display Count (New Line Every 4)] %= 4 + 0 
 | | | | |■Condition (Number):   [1] CSelf23[State Display Count (New Line Every 4)] ==  0  
 | | | | |-◇Condition:  [1]  [ CSelf23[State Display Count (New Line Every 4)] == 0   ] Case↓
 | | | | | |■Set String: CSelf9[State Display Text] += "\n"
 | | | | | |■
 | | | | |◇End◇
 | | | | |■
 | | | |◇End◇
 | | | |■Condition (Number):   [1] CSelf24[Put Slash (/) in State Display?] ==  1  
 | | | |-◇Condition:  [1]  [ CSelf24[Put Slash (/) in State Display?] == 1   ] Case↓
 | | | | |■Condition (Number):   [1] CSelf23[State Display Count (New Line Every 4)] !=  0  
 | | | | |-◇Condition:  [1]  [ CSelf23[State Display Count (New Line Every 4)] != 0   ] Case↓
 | | | | | |■Set String: CSelf9[State Display Text] += "/"
 | | | | | |■
 | | | | |◇End◇
 | | | | |■
 | | | |◇End◇
 | | | |■Load DB(User):  CSelf9[State Display Text] += UserDB[ "States":CSelf11[Processing State ID]:"Display Name" ] (8:-:2) 
 | | | |■Set Variable: CSelf23[State Display Count (New Line Every 4)] += 1 + 0 
 | | | |■
 | | |◇End◇
 | | |■
 | |◇End◇
 | |■
 |◇Loop End Point◇◇
 |▼ Copy to maximum removal turns. This value is used when reducing the remaining steps of all states at once during state removal.
 |■Load DB(Var):  CSelf17[Turns Left] = VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Tmp] UntilNextStateRemove" ] (17:-:13) 
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Tmp] NextStateRemoveMax" ] (17:-:14) =  CSelf17[Turns Left]
 |▼ Store state display string.
 |■Write to DB(Var): VarDB[ "×Allies Temp Data":CSelf0[Ally ID]:"[Temp] State Names" ] (17:-:15) =  CSelf9[State Display Text]
 |▼  
 |▼ If no states are removed by turn progression,
 |▼ the remaining steps until the next state removal will be 999999 at this point, but it's not a problem.
 |▼ (This counter triggers state removal when it reaches 0, so keep it at 999999 to prevent that process from occurring.)
 |■
◇Loop End Point◇◇
■
[COMMAND_TEXT_END]
